




fn main() {
    /// Текст из главы 3.1 Rust book.
    /// По умолчанию переменные неизменяемы.
    /// Это один из многих стимулов Rust, позволяющий писать код с использованием преимущества безопасности
    /// и удобной конкурентности (concurrency),предоставляемых Rust.
    /// Для объявления неизменяемых переменных используется let (в нотации snake_case).
    /// Для объявления изменяемых переменных используется let mut (в нотации snake_case).
    /// Для объявления констант используется слово const (в нотации SCREAMING_SNAKE_CASE).


    let x = 5;
    //x = 6; // error: cannot assign twice to immutable variable

    let mut y = 5;
    println!("y = {}", y);
    y = 6;
    println!("y = {}", y);

    /// Чистая функция
    fn add_one_map(vec: &Vec<i32>) -> Vec<i32> {
        vec.iter().map(|x| x + 1).collect()
    }

    let vec1 = vec![1, 2, 3, 4, 5];
    println!("До вызова функции: {:?}", vec1);
    let incremented_vec = add_one_map(&vec1);
    println!("Наш вектор {:?}, вектор после вызова функции: {:?}", vec1, incremented_vec);





    /// В большинстве случаев, вы легко определите побочная(в плане изменения состояния перменной) ваша функция или нет,
    /// потому что будет исползоваться мутабельная ссылка (&mut) и сама переменная будет мутабельной (let mut).
    fn remove_last_element(vec: &mut Vec<i32>) {
        vec.pop();
    }

    /// Мутабельная переменная.
    let mut vec2 = vec![1, 2, 3, 4, 5];
    println!("До вызова функции: {:?}", vec2);
    remove_last_element(&mut vec2);
    println!("После вызова функции: {:?}", vec2);


    /// Функции которые взаимодействуют с вводом/выводом данных тоже являются функциями с побочным эффектом,
    /// даже если выполняемая операция является чистой
    /// Например возьмем add_one_map добавим в нее println!

    fn add_one_map_print(vec: &Vec<i32>) -> Vec<i32> {
        vec.iter().map(|x| {
            println!("x = {}", x);
            x + 1
        }).collect()
    }


    let vec3 = vec![1, 2, 3, 4, 5];
    println!("До вызова функции: {:?}", vec3);
    let incremented_print_vec = add_one_map_print(&vec3);
    println!("Наш вектор {:?}, вектор после вызова функции: {:?}", vec3, incremented_print_vec);

    /// Перейдем к константам.
    /// Текст из главы 3.1 Rust book.
    /// Подобно неизменяемым переменным, константы — это значения, которые связаны с именем и не могут изменяться,
    /// но между константами и переменными есть несколько различий.
    /// Во-первых, нельзя использовать mut с константами. Константы не просто неизменяемы по умолчанию — они неизменяемы всегда.
    /// Для объявления констант используется ключевое слово const вместо let, а также тип значения должен быть указан в аннотации.
    /// Константы существуют в течение всего времени работы программы в пределах области, в которой они были объявлены.
    /// Это свойство делает константы полезными для значений в домене вашего приложения,
    /// о которых могут знать несколько частей программы, например,
    /// максимальное количество очков, которое может заработать любой игрок в игре,
    /// или скорость света. Обозначение жёстко закодированных значений, используемых в программе,
    /// как константы полезно для передачи смысла этого значения будущим сопровождающим кода.
    /// Это также позволяет иметь единственное место в коде, которое нужно будет изменить, если в будущем потребуется обновить значение.

    /// Можно объявить функцию как константу, но она должна выполняться только во время компиляции.
    /// Например

    const fn square(x: u32) -> u32 {
        x.pow(2)
    }
    const FOUR: u32 = square(2);
    println!("FOUR = {}", FOUR);

    /// Если вы работаете со строками, то они должны иметь статическое время жизни
    /// Например

    /// В данном случае нам не понадобилось указывать 'static так как у нас уже есть &str(который по умолчанию имеет 'static),
    /// компилятор автоматически понимает, что и &str имеет статическое время жизни даже если мы его явно не указали.
    const GREETINGS: &str = "Hello Rustacean!";

    fn greet() {
        println!("{}", GREETINGS);
    }
    greet();


    /// Рассмотрим случай немного сложнее

    pub struct User {
        //name: &str, //Missing lifetime specifier
        //surname: &str //Missing lifetime specifier
        name: &'static str,
        surname: &'static str
    }

    pub const USER: User = User {
        name: "Van",
        surname: "Darkholme"
    };

}
