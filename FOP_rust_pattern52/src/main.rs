

pub enum Email {
    AdminEmail(String),
    UserEmail(String),
    NotEmail,
    ManagerEmail(String), // После добавления этого поля, компилятор должен показать ошибку у match ниже (потому что теперь не все кейсы обрабатываются)
}


/// В Rust, паттерн-матчинг не предоставляет "safe guard" в том смысле,
/// как это делает TypeScript с использованием типовых стражей (`type guards`).
/// В TypeScript типовые стражи позволяют проверять и приводить типы во время выполнения для уточнения типов переменных.
/// В Rust, статическая типизация и строгая система типов позволяют избегать многих ошибок времени выполнения,
/// которые могли бы возникнуть в языках с динамической типизацией, таких как JavaScript и TypeScript.
/// Это означает, что Rust обеспечивает безопасность типов на этапе компиляции, что делает код более надежным,
/// но не требует типовых стражей на этапе выполнения.
/// В Rust, вместо типовых стражей, обычно используются соответствующие варианты перечисления или паттерны,
/// чтобы точно сопоставить и обработать различные варианты значений.
/// Если вы используете паттерн-матчинг правильно и учитываете все варианты,
/// вам не нужно беспокоиться о типовых стражах или проверках типов на этапе выполнения


pub fn register(email: Email) {
    match email {
        Email::AdminEmail(_) => {
            println!("Admin email")
        }
        Email::UserEmail(_) => {
            println!("User email")
        }
        Email::NotEmail => {
            println!("Not email")
        }
        //Email::ManagerEmail(_) => {
            //println!("Manager email")
        //}
    }
}




fn main() {
    let admin_email = register(Email::AdminEmail("admin@".to_string()));
    //println!("{:?}", c);
}
